{-# LANGUAGE DataKinds, FlexibleContexts,
    OverloadedStrings, GADTs, PolyKinds, TypeFamilies, ScopedTypeVariables #-}

module TransformSpec (transformSpec) where

import Hedgehog
import qualified Hedgehog.Gen as Gen
import qualified Hedgehog.Range as Range
import Test.Tasty (TestTree, localOption, Timeout(Timeout))
import Test.Tasty.Hedgehog (fromGroup)

import ArrowCFSF
import Transform
import TestHelpers
import TransformGen
import Run
import ArbitraryProgram
import Optimise (optimiseCFSF)

import FRP.Yampa (deltaEncode, embed, SF, iPre)
import qualified Control.Arrow as A
import System.Timeout (timeout)
import Control.Monad.IO.Class
import Data.Maybe (fromJust)
import Control.Exception

-- * Test `transform`.
-- General idea is to test a prewritten program against a Yampa equivalent.

removeDesc :: Val a -> Simplify a
removeDesc (One a) = a
removeDesc (Pair a b) = (removeDesc a, removeDesc b)

-- NOTE: While Tasty has a feature for timeouts, it doesn't allow us to access
-- the inputs generated by Hedgehog... so we manually add timeouts.
checkEqualTransform :: (Eq (Simplify a), Eq (Simplify b), Show (Simplify b), ValidDesc a, ValidDesc b) =>
    (CFSF a b, SF (Simplify a) (Simplify b)) -> ([Val a], [Simplify a]) -> PropertyT IO ()
checkEqualTransform (cfsf, sf) (ins, ins') = do
    let sfres = embed sf (deltaEncode 1 ins')
    cfsf' <- liftIO $ timeout 1000000 $ handle (\(e :: SomeException) -> error (show cfsf)) $ return $! transform cfsf
    case cfsf' of
        Just cfsf'' -> do
            let cfsfres = map removeDesc $ multiRun runCFSF cfsf'' ins
            sfres === cfsfres
        Nothing -> footnote "Test timed out." >> failure

-- This makes sure that `transform` leaves programs without loops entirely unaffected.
prop_transform_noloop :: Property
prop_transform_noloop = property $ do
    (ins, ins') <- forAll genPairVals
    len <- forAll $ Gen.integral (Range.linear 1 10)
    (cfsf, sf) <- forAllWith (show . fst) $ genPairProg len
    checkEqualTransform (cfsf, sf) (ins, ins')

-- This makes sure that `transform` leaves loops where the `pre` is already in the right place as-is.
prop_transform_trivial :: Property
prop_transform_trivial = property $ do
    (ins, ins') <- forAll genOneVals
    len <- forAll $ Gen.integral (Range.linear 1 10)
    (cfsf, sf) <- forAllWith (show . fst) $ genPairProg len
    (del, del') <- forAll genOneVal
    checkEqualTransform (loop $ cfsf >>> second (pre del), A.loop $ sf A.>>> A.second (iPre del')) (ins, ins')

-- This makes sure that simple right slides can be used to move the `pre` into position.
prop_right_slide :: Property
prop_right_slide = property $ do
    (ins, ins') <- forAll genOneVals
    (cfsf, sf) <- forAllWith (show . fst) makeRightSlider
    checkEqualTransform (cfsf, sf) (ins, ins')

-- This makes sure that we are able to extract the correct value for a pre even
-- when it is a pair - i.e. a loop ending in second (pre i *** pre j) correctly
-- extracts (i,j).
prop_pre_merge :: Property
prop_pre_merge = property $ do
    (ins, ins') <- forAll genOneVals
    pairLen <- forAll $ Gen.integral (Range.linear 1 10)
    singleLen <- forAll $ Gen.integral (Range.linear 1 2)
    (cfsfmain, sfmain) <- forAllWith (show . fst) $ genPairProg pairLen
    -- We turn this into the tail by using `second`
    (cfsftail, sftail) <- forAllWith (show . fst) $ genPairProg singleLen
    (del, del') <- forAll genPairVal
    let cfsf = loop $ second mergeCFSF >>> cfsfmain >>> second (splitCFSF >>> pre del >>> cfsftail)
        sf = A.loop $ A.second mergeSF A.>>> sfmain A.>>> A.second (splitSF A.>>> iPre del' A.>>> sftail)
    checkEqualTransform (cfsf, sf) (ins, ins')

-- This checks for right fills.
prop_right_fill :: Property
prop_right_fill = property $ do
    (ins, ins') <- forAll genOneVals
    (cfsf, sf) <- forAllWith (show . fst) makeRightCrusher
    checkEqualTransform (cfsf, sf) (ins, ins')

-- This makes sure that simple left slides can be used to move the `pre` into position.
prop_left_slide :: Property
prop_left_slide = property $ do
    (ins, ins') <- forAll genOneVals
    (cfsf, sf) <- forAllWith (show . fst) makeLeftSlider
    checkEqualTransform (cfsf, sf) (ins, ins')

prop_loopM :: Property
prop_loopM = property $ do
    (ins, ins') <- forAll genOneVals
    (cfsf, sf) <- forAllWith (show . fst) makeLoopM
    checkEqualTransform (cfsf, sf) (ins, ins')

-- Two right sliding loops, one inside another. They each have their own $pre$.
prop_loop_in_loop :: Property
prop_loop_in_loop = property $ do
    (ins, ins') <- forAll genOneVals
    (cfsfinner, sfinner) <- forAllWith (show . fst) $ Gen.choice [makeRightSlider, makeLeftSlider]
    len <- forAll $ Gen.integral (Range.linear 1 3)
    len' <- forAll $ Gen.integral (Range.linear 1 3)
    (cfsfextra, sfextra) <- forAllWith (show . fst) $ genSingleProg len
    (cfsf, sf) <- forAllWith (show . fst) $ Gen.element [
            (loop $ first cfsfinner >>> second (pre (One 0) >>> cfsfextra),
                A.loop $ A.first sfinner A.>>> A.second (iPre 0 A.>>> sfextra))
        ]
    checkEqualTransform (cfsf, sf) (ins, ins')

-- Make sure a pair of loops works.
prop_pair_loop :: Property
prop_pair_loop = property $ do
    (ins, ins') <- forAll genPairVals
    (cfsfleft, sfleft) <- forAllWith (show . fst) makeRightSlider
    (cfsfright, sfright) <- forAllWith (show . fst) makeRightSlider
    let cfsf = cfsfleft *** cfsfright
        sf = sfleft A.*** sfright
    checkEqualTransform (cfsf, sf) (ins, ins')

-- Test where an inner loop acts as the pre for an outer loop
prop_depends_pre :: Property
prop_depends_pre = property $ do
    (ins, ins') <- forAll genOneVals 
    len <- forAll $ Gen.integral (Range.linear 1 3)
    len' <- forAll $ Gen.integral (Range.linear 1 3)
    (cfsfinner, sfinner) <- forAllWith (show . fst) $ genPairProg len
    (cfsfouter, sfouter) <- forAllWith (show . fst) $ genPairProg len'
    (cfsfdel, sfdel) <- forAll genPairVal 
    let cfsf = loop (cfsfouter >>> second (loop (cfsfinner >>> pre cfsfdel)))
        sf = A.loop (sfouter A.>>> A.second (A.loop (sfinner A.>>> iPre sfdel)))
    checkEqualTransform (cfsf, sf) (ins, ins')

-- Test where an inner LoopM is the pre of an outer loop.
prop_depends_loopM :: Property
prop_depends_loopM = property $ do
    (ins, ins') <- forAll genOneVals
    (cfsf, sf) <- forAllWith (show . fst) makeLoopM
    len <- forAll $ Gen.integral (Range.linear 1 3)
    (cfsfouter, sfouter) <- forAllWith (show . fst) $ genPairProg len
    let cfsf' = loop (cfsfouter >>> second cfsf)
        sf' = A.loop (sfouter A.>>> A.second sf)
    checkEqualTransform (cfsf', sf') (ins, ins')

prop_transform_into_noloop :: Property
prop_transform_into_noloop = property $ do
    len <- forAll $ Gen.integral (Range.linear 1 3)
    len' <- forAll $ Gen.integral (Range.linear 1 3)
    (ins, ins') <- forAll genOneVals
    (cfsf1, sf1) <- forAllWith (show . fst) $ genSingleProg len
    (cfsf2, sf2) <- forAllWith (show . fst) $ genSingleProg len'
    let cfsf' = loop (cfsf1 *** cfsf2)
        sf' = A.loop (sf1 A.*** sf2)
    checkEqualTransform (cfsf', sf') (ins, ins')

prop_arbitrary_program :: Property
prop_arbitrary_program = {- withTests 20000 $ -} property $ do
    len <- forAll $ Gen.integral (Range.linear 1 150)
    (ins, ins') <- forAll $ genDoubles 20
    (cfsf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len Nothing)
    checkEqualTransform (cfsf, sf) (ins, ins')

prop_deep_program :: Property
prop_deep_program = property $ do
    len <- forAll $ Gen.integral (Range.linear 100 150)
    let structure = Just [2,2,2]
    (ins, ins') <- forAll $ genDoubles 20
    (cfsf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len structure)
    checkEqualTransform (cfsf, sf) (ins, ins')

prop_shallow_program :: Property
prop_shallow_program = property $ do
    len <- forAll $ Gen.integral (Range.linear 40 80)
    depth <- forAll $ Gen.integral (Range.linear 1 10)
    let structure = Just [depth]
    (ins, ins') <- forAll $ genDoubles 20
    (cfsf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len structure)
    checkEqualTransform (cfsf, sf) (ins, ins')

prop_optimise :: Property
prop_optimise = property $ do
    len <- forAll $ Gen.integral (Range.linear 1 150)
    (ins, ins') <- forAll $ genDoubles 20
    (cfsf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len Nothing)
    checkEqualTransform' (optimiseCFSF cfsf, sf) (ins, ins')
    where
        checkEqualTransform' :: (Eq (Simplify a), Eq (Simplify b), Show (Simplify b), ValidDesc a, ValidDesc b) =>
            (CFSF a b, SF (Simplify a) (Simplify b)) -> ([Val a], [Simplify a]) -> PropertyT IO ()
        checkEqualTransform' (cfsf, sf) (ins, ins') = do
            let sfres = embed sf (deltaEncode 1 ins')
            cfsf' <- liftIO $ timeout 1000000 $ handle (\(e :: SomeException) -> error (show cfsf)) $ return $! transform cfsf
            case optimiseCFSF <$> cfsf' of
                Just cfsf'' -> do
                    let cfsfres = map removeDesc $ multiRun runCFSF cfsf'' ins
                    sfres === cfsfres
                Nothing -> footnote "Test timed out." >> failure

transformSpec :: TestTree 
transformSpec = fromGroup $ Group "Transform works and preserves program meaning" [
        ("Programs without loops are unaffected", prop_transform_noloop),
        ("Loops with `pre` in the right place for LoopD already can be transformed", prop_transform_trivial),
        ("Loops which can be transformed with simple right slides work", prop_right_slide),
        ("Loops with (pre i *** pre j) work", prop_pre_merge),
        ("Loops where right fill is required work", prop_right_fill),
        ("Loops which can be transformed with left slides work", prop_left_slide),
        ("Loops which tansform into LoopM work", prop_loopM),
        ("A pair of nested loops which do not affect each other can be transformed", prop_loop_in_loop),
        ("Two loops in parallel can be transformed", prop_pair_loop),
        ("A nested loop which contains the `pre` needed by the outer loop works", prop_depends_pre),
        ("A nested loop which transforms into LoopM can be used as `pre` for the outer loop", prop_depends_loopM),
        ("A loop which should be removed can be transformed", prop_transform_noloop),
        ("An arbitrary program can be transformed", prop_arbitrary_program),
        ("An arbitrary program with lots of nested loops can be transformed", prop_deep_program),
        ("An arbitrary program with lots of composed loops can be transformed", prop_shallow_program),
        ("Optimising the output program does not change its meaning", prop_optimise)
    ]