{-# LANGUAGE TemplateHaskell, DataKinds, FlexibleContexts, StandaloneKindSignatures,
    OverloadedStrings, GADTs, PolyKinds, TypeFamilies, ExplicitForAll, BangPatterns,
    TypeApplications, ScopedTypeVariables #-}

module TransformSpec (transformSpec) where

import Hedgehog
import qualified Hedgehog.Gen as Gen
import qualified Hedgehog.Range as Range
import Test.Tasty.Hedgehog (fromGroup)
import Test.Tasty (TestTree, localOption, Timeout(Timeout))

import ArrowNF
import Transform
import TestHelpers
import LoopGen
import Run
import ArbitraryProgram

import FRP.Yampa (deltaEncode, embed, SF, iPre)
import qualified Control.Arrow as A
import System.Timeout (timeout)
import Control.Monad.IO.Class
import Data.Maybe (fromJust)
import Control.Exception
import Optimise (optimiseCF)

-- * Test `transform`.
-- General idea is to test a prewritten program against a Yampa equivalent.

removeDesc :: Val a -> Simplify a
removeDesc (One a) = a
removeDesc (Pair a b) = (removeDesc a, removeDesc b)

-- NOTE: While Tasty has a feature for timeouts, it doesn't allow us to access
-- the inputs generated by Hedgehog... so we manually add timeouts.
checkEqualTransform :: (Eq (Simplify a), Eq (Simplify b), Show (Simplify b), ValidDesc a, ValidDesc b) =>
    (CF a b, SF (Simplify a) (Simplify b)) -> ([Val a], [Simplify a]) -> PropertyT IO ()
checkEqualTransform (cf, sf) (ins, ins') = do
    let sfres = embed sf (deltaEncode 1 ins')
    cf' <- liftIO $ timeout 1000000 $ handle (\(e :: SomeException) -> error (show cf)) $ return $! transform cf
    case cf' of
        Just cf'' -> do
            let cfres = map removeDesc $ multiRun runCF cf'' ins
            sfres === cfres
        Nothing -> footnote "Test timed out." >> failure

-- This makes sure that `transform` leaves programs without loops entirely unaffected.
prop_transform_noloop :: Property
prop_transform_noloop = property $ do
    (ins, ins') <- forAll genPairVals
    len <- forAll $ Gen.integral (Range.linear 1 10)
    (cf, sf) <- forAllWith (show . fst) $ genPairProg len
    checkEqualTransform (cf, sf) (ins, ins')

-- This makes sure that `transform` leaves loops where the `pre` is already in the right place as-is.
prop_transform_trivial :: Property
prop_transform_trivial = property $ do
    (ins, ins') <- forAll genOneVals
    len <- forAll $ Gen.integral (Range.linear 1 10)
    (cf, sf) <- forAllWith (show . fst) $ genPairProg len
    (del, del') <- forAll genOneVal
    checkEqualTransform (loop $ cf >>> second (pre del), A.loop $ sf A.>>> A.second (iPre del')) (ins, ins')

-- This makes sure that simple right slides can be used to move the `pre` into position.
prop_right_slide :: Property
prop_right_slide = property $ do
    (ins, ins') <- forAll genOneVals
    (cf, sf) <- forAllWith (show . fst) makeRightSlider
    checkEqualTransform (cf, sf) (ins, ins')

-- This makes sure that we are able to extract the correct value for a pre even
-- when it is a pair - i.e. a loop ending in second (pre i *** pre j) correctly
-- extracts (i,j).
prop_pre_merge :: Property
prop_pre_merge = property $ do
    (ins, ins') <- forAll genOneVals
    pairLen <- forAll $ Gen.integral (Range.linear 1 10)
    singleLen <- forAll $ Gen.integral (Range.linear 1 2)
    (cfmain, sfmain) <- forAllWith (show . fst) $ genPairProg pairLen
    -- We turn this into the tail by using `second`
    (cftail, sftail) <- forAllWith (show . fst) $ genPairProg singleLen
    (del, del') <- forAll genPairVal
    let cf = loop $ second mergeCF >>> cfmain >>> second (splitCF >>> pre del >>> cftail)
        sf = A.loop $ A.second mergeSF A.>>> sfmain A.>>> A.second (splitSF A.>>> iPre del' A.>>> sftail)
    checkEqualTransform (cf, sf) (ins, ins')

-- This makes sure that the right crush property is applied - i.e. if we have
-- (a *** b) >>> (id *** c)
-- we get
-- (id *** b) >>> (a *** c) [and similar for a *** b >>> c *** id]
-- TODO: This test nondeterministically times out.
prop_right_crush :: Property
prop_right_crush = property $ do
    (ins, ins') <- forAll genOneVals
    (cf, sf) <- forAllWith (show . fst) makeRightCrusher
    checkEqualTransform (cf, sf) (ins, ins')

-- This makes sure that simple left slides can be used to move the `pre` into position.
prop_left_slide :: Property
prop_left_slide = property $ do
    (ins, ins') <- forAll genOneVals
    (cf, sf) <- forAllWith (show . fst) makeLeftSlider
    checkEqualTransform (cf, sf) (ins, ins')

prop_loopM :: Property
prop_loopM = property $ do
    (ins, ins') <- forAll genOneVals
    (cf, sf) <- forAllWith (show . fst) makeLoopM
    checkEqualTransform (cf, sf) (ins, ins')

-- Two right sliding loops, one inside another. They each have their own $pre$.
prop_loop_in_loop :: Property
prop_loop_in_loop = property $ do
    (ins, ins') <- forAll genOneVals
    (cfinner, sfinner) <- forAllWith (show . fst) $ Gen.choice [makeRightSlider, makeLeftSlider]
    len <- forAll $ Gen.integral (Range.linear 1 3)
    len' <- forAll $ Gen.integral (Range.linear 1 3)
    (cfextra, sfextra) <- forAllWith (show . fst) $ genSingleProg len
    (cf, sf) <- forAllWith (show . fst) $ Gen.element [
            (loop $ first cfinner >>> second (pre (One 0) >>> cfextra),
                A.loop $ A.first sfinner A.>>> A.second (iPre 0 A.>>> sfextra))
        ]
    checkEqualTransform (cf, sf) (ins, ins')

-- Make sure a pair of loops works.
prop_pair_loop :: Property
prop_pair_loop = property $ do
    (ins, ins') <- forAll genPairVals
    (cfleft, sfleft) <- forAllWith (show . fst) makeRightSlider
    (cfright, sfright) <- forAllWith (show . fst) makeRightSlider
    let cf = cfleft *** cfright
        sf = sfleft A.*** sfright
    checkEqualTransform (cf, sf) (ins, ins')

-- Test where an inner loop acts as the pre for an outer loop
-- TODO: can we make a more complex version of this? e.g. when there's other things to tighten before the pre,
-- when it's at the front of the loop instead of the back etc.
prop_depends_pre :: Property
prop_depends_pre = property $ do
    (ins, ins') <- forAll genOneVals 
    len <- forAll $ Gen.integral (Range.linear 1 3)
    len' <- forAll $ Gen.integral (Range.linear 1 3)
    (cfinner, sfinner) <- forAllWith (show . fst) $ genPairProg len
    (cfouter, sfouter) <- forAllWith (show . fst) $ genPairProg len'
    (cfdel, sfdel) <- forAll genPairVal 
    let cf = loop (cfouter >>> second (loop (cfinner >>> pre cfdel)))
        sf = A.loop (sfouter A.>>> A.second (A.loop (sfinner A.>>> iPre sfdel)))
    checkEqualTransform (cf, sf) (ins, ins')

-- Test where an inner LoopM is the pre of an outer loop.
-- TODO: a test where it's a mix of Pre and LoopM
prop_depends_loopM :: Property
prop_depends_loopM = property $ do
    (ins, ins') <- forAll genOneVals
    (cf, sf) <- forAllWith (show . fst) makeLoopM
    len <- forAll $ Gen.integral (Range.linear 1 3)
    (cfouter, sfouter) <- forAllWith (show . fst) $ genPairProg len
    let cf' = loop (cfouter >>> second cf)
        sf' = A.loop (sfouter A.>>> A.second sf)
    checkEqualTransform (cf', sf') (ins, ins')

prop_transform_into_noloop :: Property
prop_transform_into_noloop = property $ do
    len <- forAll $ Gen.integral (Range.linear 1 3)
    len' <- forAll $ Gen.integral (Range.linear 1 3)
    (ins, ins') <- forAll genOneVals
    (cf1, sf1) <- forAllWith (show . fst) $ genSingleProg len
    (cf2, sf2) <- forAllWith (show . fst) $ genSingleProg len'
    let cf' = loop (cf1 *** cf2)
        sf' = A.loop (sf1 A.*** sf2)
    checkEqualTransform (cf', sf') (ins, ins')

prop_arbitrary_program :: Property
prop_arbitrary_program = {- withTests 20000 $ -} property $ do
    len <- forAll $ Gen.integral (Range.linear 1 150)
    (ins, ins') <- forAll $ genDoubles 20
    (cf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len Nothing)
    checkEqualTransform (cf, sf) (ins, ins')

prop_deep_program :: Property
prop_deep_program = property $ do
    len <- forAll $ Gen.integral (Range.linear 100 150)
    let structure = Just [2,2,2]
    (ins, ins') <- forAll $ genDoubles 20
    (cf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len structure)
    checkEqualTransform (cf, sf) (ins, ins')

prop_shallow_program :: Property
prop_shallow_program = property $ do
    len <- forAll $ Gen.integral (Range.linear 40 80)
    depth <- forAll $ Gen.integral (Range.linear 1 10)
    let structure = Just [depth]
    (ins, ins') <- forAll $ genDoubles 20
    (cf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len structure)
    checkEqualTransform (cf, sf) (ins, ins')

prop_optimise :: Property
prop_optimise = property $ do
    len <- forAll $ Gen.integral (Range.linear 1 150)
    (ins, ins') <- forAll $ genDoubles 20
    (cf, sf) <- forAllWith (show . fst) $ Gen.just $ genProg ProxV ProxV (GP len Nothing)
    checkEqualTransform' (cf, sf) (ins, ins')
    where
        checkEqualTransform' :: (Eq (Simplify a), Eq (Simplify b), Show (Simplify b), ValidDesc a, ValidDesc b) =>
            (CF a b, SF (Simplify a) (Simplify b)) -> ([Val a], [Simplify a]) -> PropertyT IO ()
        checkEqualTransform' (cf, sf) (ins, ins') = do
            let sfres = embed sf (deltaEncode 1 ins')
            cf' <- liftIO $ timeout 1000000 $ handle (\(e :: SomeException) -> error (show cf)) $ return $! transform cf
            case optimiseCF <$> cf' of
                Just cf'' -> do
                    let cfres = map removeDesc $ multiRun runCF cf'' ins
                    sfres === cfres
                Nothing -> footnote "Test timed out." >> failure

transformSpec :: TestTree 
transformSpec = fromGroup $ $$(discover) {groupName = "Transform produces equivalent programs"}